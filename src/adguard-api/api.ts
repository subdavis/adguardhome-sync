// tslint:disable
/**
 * AdGuard Home
 * AdGuard Home REST API. Admin web interface is built on top of this REST API.
 *
 * The version of the OpenAPI document: 0.102
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * /add_url request data
 * @export
 * @interface AddUrlRequest
 */
export interface AddUrlRequest {
    /**
     * 
     * @type {string}
     * @memberof AddUrlRequest
     */
    name?: string;
    /**
     * URL or an absolute path to the file containing filtering rules
     * @type {string}
     * @memberof AddUrlRequest
     */
    url?: string;
}
/**
 * Port information
 * @export
 * @interface AddressInfo
 */
export interface AddressInfo {
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof AddressInfo
     */
    port?: number;
}
/**
 * AdGuard Home addresses configuration
 * @export
 * @interface AddressesInfo
 */
export interface AddressesInfo {
    /**
     * 
     * @type {number}
     * @memberof AddressesInfo
     */
    dns_port?: number;
    /**
     * 
     * @type {number}
     * @memberof AddressesInfo
     */
    web_port?: number;
    /**
     * Network interfaces dictionary (key is the interface name)
     * @type {{ [key: string]: NetInterface; }}
     * @memberof AddressesInfo
     */
    interfaces?: { [key: string]: NetInterface; };
}
/**
 * Configuration to be checked
 * @export
 * @interface CheckConfigRequest
 */
export interface CheckConfigRequest {
    /**
     * 
     * @type {CheckConfigRequestInfo}
     * @memberof CheckConfigRequest
     */
    dns?: CheckConfigRequestInfo;
    /**
     * 
     * @type {CheckConfigRequestInfo}
     * @memberof CheckConfigRequest
     */
    web?: CheckConfigRequestInfo;
    /**
     * 
     * @type {boolean}
     * @memberof CheckConfigRequest
     */
    set_static_ip?: boolean;
}
/**
 * 
 * @export
 * @interface CheckConfigRequestInfo
 */
export interface CheckConfigRequestInfo {
    /**
     * 
     * @type {string}
     * @memberof CheckConfigRequestInfo
     */
    ip?: string;
    /**
     * 
     * @type {number}
     * @memberof CheckConfigRequestInfo
     */
    port?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckConfigRequestInfo
     */
    autofix?: boolean;
}
/**
 * 
 * @export
 * @interface CheckConfigResponse
 */
export interface CheckConfigResponse {
    /**
     * 
     * @type {CheckConfigResponseInfo}
     * @memberof CheckConfigResponse
     */
    dns?: CheckConfigResponseInfo;
    /**
     * 
     * @type {CheckConfigResponseInfo}
     * @memberof CheckConfigResponse
     */
    web?: CheckConfigResponseInfo;
    /**
     * 
     * @type {CheckConfigStaticIpInfo}
     * @memberof CheckConfigResponse
     */
    static_ip?: CheckConfigStaticIpInfo;
}
/**
 * 
 * @export
 * @interface CheckConfigResponseInfo
 */
export interface CheckConfigResponseInfo {
    /**
     * 
     * @type {string}
     * @memberof CheckConfigResponseInfo
     */
    status?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CheckConfigResponseInfo
     */
    can_autofix?: boolean;
}
/**
 * 
 * @export
 * @interface CheckConfigStaticIpInfo
 */
export interface CheckConfigStaticIpInfo {
    /**
     * Can be: yes, no, error
     * @type {string}
     * @memberof CheckConfigStaticIpInfo
     */
    _static?: string;
    /**
     * Current dynamic IP address. Set if static=no
     * @type {string}
     * @memberof CheckConfigStaticIpInfo
     */
    ip?: string;
    /**
     * Error text. Set if static=error
     * @type {string}
     * @memberof CheckConfigStaticIpInfo
     */
    error?: string;
}
/**
 * Client information
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * Name
     * @type {string}
     * @memberof Client
     */
    name?: string;
    /**
     * IP, CIDR or MAC address
     * @type {Array<string>}
     * @memberof Client
     */
    ids?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    use_global_settings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    filtering_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    parental_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    safebrowsing_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    safesearch_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    use_global_blocked_services?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Client
     */
    blocked_services?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Client
     */
    upstreams?: Array<string>;
}
/**
 * Auto-Client information
 * @export
 * @interface ClientAuto
 */
export interface ClientAuto {
    /**
     * IP address
     * @type {string}
     * @memberof ClientAuto
     */
    ip?: string;
    /**
     * Name
     * @type {string}
     * @memberof ClientAuto
     */
    name?: string;
    /**
     * The source of this information
     * @type {string}
     * @memberof ClientAuto
     */
    source?: string;
}
/**
 * Client delete request
 * @export
 * @interface ClientDelete
 */
export interface ClientDelete {
    /**
     * 
     * @type {string}
     * @memberof ClientDelete
     */
    name?: string;
}
/**
 * Client update request
 * @export
 * @interface ClientUpdate
 */
export interface ClientUpdate {
    /**
     * 
     * @type {string}
     * @memberof ClientUpdate
     */
    name?: string;
    /**
     * 
     * @type {Client}
     * @memberof ClientUpdate
     */
    data?: Client;
}
/**
 * 
 * @export
 * @interface Clients
 */
export interface Clients {
    /**
     * Clients array
     * @type {Array<Client>}
     * @memberof Clients
     */
    clients?: Array<Client>;
    /**
     * Auto-Clients array
     * @type {Array<ClientAuto>}
     * @memberof Clients
     */
    auto_clients?: Array<ClientAuto>;
}
/**
 * 
 * @export
 * @interface ClientsFindEntry
 */
export interface ClientsFindEntry {
    /**
     * 
     * @type {object}
     * @memberof ClientsFindEntry
     */
    _1_2_3_4?: object;
}
/**
 * Query log configuration
 * @export
 * @interface DNSConfig
 */
export interface DNSConfig {
    /**
     * Bootstrap servers, port is optional after colon. Empty value will reset it to default values
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    bootstrap_dns?: Array<string>;
    /**
     * Upstream servers, port is optional after colon. Empty value will reset it to default values
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    upstream_dns?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DNSConfig
     */
    protection_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DNSConfig
     */
    ratelimit?: number;
    /**
     * 
     * @type {string}
     * @memberof DNSConfig
     */
    blocking_mode?: DNSConfigBlockingModeEnum;
    /**
     * 
     * @type {string}
     * @memberof DNSConfig
     */
    blocking_ipv4?: string;
    /**
     * 
     * @type {string}
     * @memberof DNSConfig
     */
    blocking_ipv6?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DNSConfig
     */
    edns_cs_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DNSConfig
     */
    dnssec_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DNSConfig
     */
    fastest_addr?: boolean;
    /**
     * If true, parallel queries to all configured upstream servers are enabled
     * @type {boolean}
     * @memberof DNSConfig
     */
    parallel_requests?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum DNSConfigBlockingModeEnum {
    Default = 'default',
    Nxdomain = 'nxdomain',
    NullIp = 'null_ip',
    CustomIp = 'custom_ip'
}

/**
 * Built-in DHCP server configuration
 * @export
 * @interface DhcpConfig
 */
export interface DhcpConfig {
    /**
     * 
     * @type {boolean}
     * @memberof DhcpConfig
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof DhcpConfig
     */
    gateway_ip: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpConfig
     */
    subnet_mask: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpConfig
     */
    range_start: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpConfig
     */
    range_end: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpConfig
     */
    lease_duration: string;
}
/**
 * DHCP lease information
 * @export
 * @interface DhcpLease
 */
export interface DhcpLease {
    /**
     * 
     * @type {string}
     * @memberof DhcpLease
     */
    mac: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpLease
     */
    ip: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpLease
     */
    hostname: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpLease
     */
    expires: string;
}
/**
 * Information about a DHCP server discovered in the current network
 * @export
 * @interface DhcpSearchResult
 */
export interface DhcpSearchResult {
    /**
     * 
     * @type {DhcpSearchResultOtherServer}
     * @memberof DhcpSearchResult
     */
    other_server?: DhcpSearchResultOtherServer;
    /**
     * 
     * @type {DhcpSearchResultStaticIP}
     * @memberof DhcpSearchResult
     */
    static_ip?: DhcpSearchResultStaticIP;
}
/**
 * 
 * @export
 * @interface DhcpSearchResultOtherServer
 */
export interface DhcpSearchResultOtherServer {
    /**
     * yes|no|error
     * @type {string}
     * @memberof DhcpSearchResultOtherServer
     */
    found?: string;
    /**
     * Set if found=error
     * @type {string}
     * @memberof DhcpSearchResultOtherServer
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface DhcpSearchResultStaticIP
 */
export interface DhcpSearchResultStaticIP {
    /**
     * yes|no|error
     * @type {string}
     * @memberof DhcpSearchResultStaticIP
     */
    _static?: string;
    /**
     * Set if static=no
     * @type {string}
     * @memberof DhcpSearchResultStaticIP
     */
    ip?: string;
}
/**
 * DHCP static lease information
 * @export
 * @interface DhcpStaticLease
 */
export interface DhcpStaticLease {
    /**
     * 
     * @type {string}
     * @memberof DhcpStaticLease
     */
    mac: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpStaticLease
     */
    ip: string;
    /**
     * 
     * @type {string}
     * @memberof DhcpStaticLease
     */
    hostname: string;
}
/**
 * Built-in DHCP server configuration and status
 * @export
 * @interface DhcpStatus
 */
export interface DhcpStatus {
    /**
     * 
     * @type {DhcpConfig}
     * @memberof DhcpStatus
     */
    config: DhcpConfig;
    /**
     * 
     * @type {Array<DhcpLease>}
     * @memberof DhcpStatus
     */
    leases: Array<DhcpLease>;
    /**
     * 
     * @type {Array<DhcpStaticLease>}
     * @memberof DhcpStatus
     */
    static_leases?: Array<DhcpStaticLease>;
}
/**
 * DNS answer section
 * @export
 * @interface DnsAnswer
 */
export interface DnsAnswer {
    /**
     * 
     * @type {number}
     * @memberof DnsAnswer
     */
    ttl?: number;
    /**
     * 
     * @type {string}
     * @memberof DnsAnswer
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DnsAnswer
     */
    value?: string;
}
/**
 * DNS question section
 * @export
 * @interface DnsQuestion
 */
export interface DnsQuestion {
    /**
     * 
     * @type {string}
     * @memberof DnsQuestion
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof DnsQuestion
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof DnsQuestion
     */
    type?: string;
}
/**
 * Filter subscription info
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {boolean}
     * @memberof Filter
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    rulesCount: number;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    url: string;
}
/**
 * Check Host Result
 * @export
 * @interface FilterCheckHostResponse
 */
export interface FilterCheckHostResponse {
    /**
     * DNS filter status
     * @type {string}
     * @memberof FilterCheckHostResponse
     */
    reason?: FilterCheckHostResponseReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof FilterCheckHostResponse
     */
    filter_id?: number;
    /**
     * Filtering rule applied to the request (if any)
     * @type {string}
     * @memberof FilterCheckHostResponse
     */
    rule?: string;
    /**
     * Set if reason=FilteredBlockedService
     * @type {string}
     * @memberof FilterCheckHostResponse
     */
    service_name?: string;
    /**
     * Set if reason=ReasonRewrite
     * @type {string}
     * @memberof FilterCheckHostResponse
     */
    cname?: string;
    /**
     * Set if reason=ReasonRewrite
     * @type {Array<string>}
     * @memberof FilterCheckHostResponse
     */
    ip_addrs?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum FilterCheckHostResponseReasonEnum {
    NotFilteredNotFound = 'NotFilteredNotFound',
    NotFilteredWhiteList = 'NotFilteredWhiteList',
    NotFilteredError = 'NotFilteredError',
    FilteredBlackList = 'FilteredBlackList',
    FilteredSafeBrowsing = 'FilteredSafeBrowsing',
    FilteredParental = 'FilteredParental',
    FilteredInvalid = 'FilteredInvalid',
    FilteredSafeSearch = 'FilteredSafeSearch',
    FilteredBlockedService = 'FilteredBlockedService',
    ReasonRewrite = 'ReasonRewrite'
}

/**
 * Filtering settings
 * @export
 * @interface FilterConfig
 */
export interface FilterConfig {
    /**
     * 
     * @type {boolean}
     * @memberof FilterConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FilterConfig
     */
    interval?: number;
}
/**
 * Refresh Filters request data
 * @export
 * @interface FilterRefreshRequest
 */
export interface FilterRefreshRequest {
    /**
     * 
     * @type {boolean}
     * @memberof FilterRefreshRequest
     */
    whitelist?: boolean;
}
/**
 * /filtering/refresh response data
 * @export
 * @interface FilterRefreshResponse
 */
export interface FilterRefreshResponse {
    /**
     * 
     * @type {number}
     * @memberof FilterRefreshResponse
     */
    updated?: number;
}
/**
 * Filtering URL settings
 * @export
 * @interface FilterSetUrl
 */
export interface FilterSetUrl {
    /**
     * 
     * @type {string}
     * @memberof FilterSetUrl
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FilterSetUrl
     */
    enabled?: boolean;
}
/**
 * Filtering settings
 * @export
 * @interface FilterStatus
 */
export interface FilterStatus {
    /**
     * 
     * @type {boolean}
     * @memberof FilterStatus
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FilterStatus
     */
    interval?: number;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof FilterStatus
     */
    filters?: Array<Filter>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterStatus
     */
    user_rules?: Array<string>;
}
/**
 * /version.json request data
 * @export
 * @interface GetVersionRequest
 */
export interface GetVersionRequest {
    /**
     * If false, server will check for a new version data only once in several hours
     * @type {boolean}
     * @memberof GetVersionRequest
     */
    recheck_now?: boolean;
}
/**
 * AdGuard Home initial configuration (for the first-install wizard)
 * @export
 * @interface InitialConfiguration
 */
export interface InitialConfiguration {
    /**
     * 
     * @type {AddressInfo}
     * @memberof InitialConfiguration
     */
    dns?: AddressInfo;
    /**
     * 
     * @type {AddressInfo}
     * @memberof InitialConfiguration
     */
    web?: AddressInfo;
    /**
     * Basic auth username
     * @type {string}
     * @memberof InitialConfiguration
     */
    username?: string;
    /**
     * Basic auth password
     * @type {string}
     * @memberof InitialConfiguration
     */
    password?: string;
}
/**
 * Login request data
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * User name
     * @type {string}
     * @memberof Login
     */
    username?: string;
    /**
     * Password
     * @type {string}
     * @memberof Login
     */
    password?: string;
}
/**
 * Network interface info
 * @export
 * @interface NetInterface
 */
export interface NetInterface {
    /**
     * 
     * @type {string}
     * @memberof NetInterface
     */
    flags?: string;
    /**
     * 
     * @type {string}
     * @memberof NetInterface
     */
    hardware_address?: string;
    /**
     * 
     * @type {number}
     * @memberof NetInterface
     */
    mtu?: number;
    /**
     * 
     * @type {string}
     * @memberof NetInterface
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetInterface
     */
    ip_addresses?: Array<string>;
}
/**
 * Information about the current user
 * @export
 * @interface ProfileInfo
 */
export interface ProfileInfo {
    /**
     * 
     * @type {string}
     * @memberof ProfileInfo
     */
    name?: string;
}
/**
 * Query log
 * @export
 * @interface QueryLog
 */
export interface QueryLog {
    /**
     * 
     * @type {string}
     * @memberof QueryLog
     */
    oldest?: string;
    /**
     * 
     * @type {Array<QueryLogItem>}
     * @memberof QueryLog
     */
    data?: Array<QueryLogItem>;
}
/**
 * Query log configuration
 * @export
 * @interface QueryLogConfig
 */
export interface QueryLogConfig {
    /**
     * Is query log enabled
     * @type {boolean}
     * @memberof QueryLogConfig
     */
    enabled?: boolean;
    /**
     * Time period to keep data (1 | 7 | 30 | 90)
     * @type {number}
     * @memberof QueryLogConfig
     */
    interval?: number;
    /**
     * Anonymize clients\' IP addresses
     * @type {boolean}
     * @memberof QueryLogConfig
     */
    anonymize_client_ip?: boolean;
}
/**
 * Query log item
 * @export
 * @interface QueryLogItem
 */
export interface QueryLogItem {
    /**
     * 
     * @type {Array<DnsAnswer>}
     * @memberof QueryLogItem
     */
    answer?: Array<DnsAnswer>;
    /**
     * Answer from upstream server (optional)
     * @type {Array<DnsAnswer>}
     * @memberof QueryLogItem
     */
    original_answer?: Array<DnsAnswer>;
    /**
     * 
     * @type {boolean}
     * @memberof QueryLogItem
     */
    answer_dnssec?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryLogItem
     */
    client?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryLogItem
     */
    elapsedMs?: string;
    /**
     * 
     * @type {DnsQuestion}
     * @memberof QueryLogItem
     */
    question?: DnsQuestion;
    /**
     * In case if there\'s a rule applied to this DNS request, this is ID of the filter that rule belongs to.
     * @type {number}
     * @memberof QueryLogItem
     */
    filterId?: number;
    /**
     * Filtering rule applied to the request (if any)
     * @type {string}
     * @memberof QueryLogItem
     */
    rule?: string;
    /**
     * DNS filter status
     * @type {string}
     * @memberof QueryLogItem
     */
    reason?: QueryLogItemReasonEnum;
    /**
     * Set if reason=FilteredBlockedService
     * @type {string}
     * @memberof QueryLogItem
     */
    service_name?: string;
    /**
     * DNS response status
     * @type {string}
     * @memberof QueryLogItem
     */
    status?: string;
    /**
     * DNS request processing start time
     * @type {string}
     * @memberof QueryLogItem
     */
    time?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryLogItemReasonEnum {
    NotFilteredNotFound = 'NotFilteredNotFound',
    NotFilteredWhiteList = 'NotFilteredWhiteList',
    NotFilteredError = 'NotFilteredError',
    FilteredBlackList = 'FilteredBlackList',
    FilteredSafeBrowsing = 'FilteredSafeBrowsing',
    FilteredParental = 'FilteredParental',
    FilteredInvalid = 'FilteredInvalid',
    FilteredSafeSearch = 'FilteredSafeSearch',
    FilteredBlockedService = 'FilteredBlockedService',
    ReasonRewrite = 'ReasonRewrite'
}

/**
 * /remove_url request data
 * @export
 * @interface RemoveUrlRequest
 */
export interface RemoveUrlRequest {
    /**
     * Previously added URL containing filtering rules
     * @type {string}
     * @memberof RemoveUrlRequest
     */
    url?: string;
}
/**
 * Rewrite rule
 * @export
 * @interface RewriteEntry
 */
export interface RewriteEntry {
    /**
     * Domain name
     * @type {string}
     * @memberof RewriteEntry
     */
    domain?: string;
    /**
     * value of A, AAAA or CNAME DNS record
     * @type {string}
     * @memberof RewriteEntry
     */
    answer?: string;
}
/**
 * AdGuard Home server status and configuration
 * @export
 * @interface ServerStatus
 */
export interface ServerStatus {
    /**
     * 
     * @type {string}
     * @memberof ServerStatus
     */
    dns_address: string;
    /**
     * 
     * @type {number}
     * @memberof ServerStatus
     */
    dns_port: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerStatus
     */
    protection_enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerStatus
     */
    querylog_enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerStatus
     */
    running: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerStatus
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof ServerStatus
     */
    language: string;
}
/**
 * Server statistics data
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Time units (hours | days)
     * @type {string}
     * @memberof Stats
     */
    time_units?: string;
    /**
     * Total number of DNS queries
     * @type {number}
     * @memberof Stats
     */
    num_dns_queries?: number;
    /**
     * Number of requests blocked by filtering rules
     * @type {number}
     * @memberof Stats
     */
    num_blocked_filtering?: number;
    /**
     * Number of requests blocked by safebrowsing module
     * @type {number}
     * @memberof Stats
     */
    num_replaced_safebrowsing?: number;
    /**
     * Number of requests blocked by safesearch module
     * @type {number}
     * @memberof Stats
     */
    num_replaced_safesearch?: number;
    /**
     * Number of blocked adult websites
     * @type {number}
     * @memberof Stats
     */
    num_replaced_parental?: number;
    /**
     * Average time in milliseconds on processing a DNS
     * @type {number}
     * @memberof Stats
     */
    avg_processing_time?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Stats
     */
    top_queried_domains?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Stats
     */
    top_clients?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Stats
     */
    top_blocked_domains?: Array<object>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Stats
     */
    dns_queries?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Stats
     */
    blocked_filtering?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Stats
     */
    replaced_safebrowsing?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Stats
     */
    replaced_parental?: Array<number>;
}
/**
 * Statistics configuration
 * @export
 * @interface StatsConfig
 */
export interface StatsConfig {
    /**
     * Time period to keep data (1 | 7 | 30 | 90)
     * @type {number}
     * @memberof StatsConfig
     */
    interval?: number;
}
/**
 * TLS configuration settings and status
 * @export
 * @interface TlsConfig
 */
export interface TlsConfig {
    /**
     * enabled is the encryption (DOT/DOH/HTTPS) status
     * @type {boolean}
     * @memberof TlsConfig
     */
    enabled?: boolean;
    /**
     * server_name is the hostname of your HTTPS/TLS server
     * @type {string}
     * @memberof TlsConfig
     */
    server_name?: string;
    /**
     * if true, forces HTTP->HTTPS redirect
     * @type {boolean}
     * @memberof TlsConfig
     */
    force_https?: boolean;
    /**
     * HTTPS port. If 0, HTTPS will be disabled.
     * @type {number}
     * @memberof TlsConfig
     */
    port_https?: number;
    /**
     * DNS-over-TLS port. If 0, DOT will be disabled.
     * @type {number}
     * @memberof TlsConfig
     */
    port_dns_over_tls?: number;
    /**
     * Base64 string with PEM-encoded certificates chain
     * @type {string}
     * @memberof TlsConfig
     */
    certificate_chain?: string;
    /**
     * Base64 string with PEM-encoded private key
     * @type {string}
     * @memberof TlsConfig
     */
    private_key?: string;
    /**
     * Path to certificate file
     * @type {string}
     * @memberof TlsConfig
     */
    certificate_path?: string;
    /**
     * Path to private key file
     * @type {string}
     * @memberof TlsConfig
     */
    private_key_path?: string;
    /**
     * valid_cert is true if the specified certificates chain is a valid chain of X509 certificates
     * @type {boolean}
     * @memberof TlsConfig
     */
    valid_cert?: boolean;
    /**
     * valid_chain is true if the specified certificates chain is verified and issued by a known CA
     * @type {boolean}
     * @memberof TlsConfig
     */
    valid_chain?: boolean;
    /**
     * subject is the subject of the first certificate in the chain
     * @type {string}
     * @memberof TlsConfig
     */
    subject?: string;
    /**
     * issuer is the issuer of the first certificate in the chain
     * @type {string}
     * @memberof TlsConfig
     */
    issuer?: string;
    /**
     * not_before is the NotBefore field of the first certificate in the chain
     * @type {string}
     * @memberof TlsConfig
     */
    not_before?: string;
    /**
     * not_after is the NotAfter field of the first certificate in the chain
     * @type {string}
     * @memberof TlsConfig
     */
    not_after?: string;
    /**
     * dns_names is the value of SubjectAltNames field of the first certificate in the chain
     * @type {Array<string>}
     * @memberof TlsConfig
     */
    dns_names?: Array<string>;
    /**
     * valid_key is true if the key is a valid private key
     * @type {boolean}
     * @memberof TlsConfig
     */
    valid_key?: boolean;
    /**
     * key_type is either RSA or ECDSA
     * @type {string}
     * @memberof TlsConfig
     */
    key_type?: string;
    /**
     * warning_validation is a validation warning message with the issue description
     * @type {string}
     * @memberof TlsConfig
     */
    warning_validation?: string;
    /**
     * valid_pair is true if both certificate and private key are correct
     * @type {boolean}
     * @memberof TlsConfig
     */
    valid_pair?: boolean;
}
/**
 * Upstreams configuration
 * @export
 * @interface UpstreamsConfig
 */
export interface UpstreamsConfig {
    /**
     * Bootstrap servers, port is optional after colon. Empty value will reset it to default values
     * @type {Array<string>}
     * @memberof UpstreamsConfig
     */
    bootstrap_dns: Array<string>;
    /**
     * Upstream servers, port is optional after colon. Empty value will reset it to default values
     * @type {Array<string>}
     * @memberof UpstreamsConfig
     */
    upstream_dns: Array<string>;
}
/**
 * Information about the latest available version of AdGuard Home
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    new_version?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    announcement?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    announcement_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VersionInfo
     */
    can_autoupdate?: boolean;
}

/**
 * BlockedServicesApi - axios parameter creator
 * @export
 */
export const BlockedServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get blocked services list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockedServicesList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blocked_services/list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set blocked services list
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockedServicesSet: async (body?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blocked_services/set`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockedServicesApi - functional programming interface
 * @export
 */
export const BlockedServicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get blocked services list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockedServicesList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await BlockedServicesApiAxiosParamCreator(configuration).blockedServicesList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set blocked services list
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockedServicesSet(body?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BlockedServicesApiAxiosParamCreator(configuration).blockedServicesSet(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BlockedServicesApi - factory interface
 * @export
 */
export const BlockedServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get blocked services list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockedServicesList(options?: any): AxiosPromise<Array<string>> {
            return BlockedServicesApiFp(configuration).blockedServicesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set blocked services list
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockedServicesSet(body?: Array<string>, options?: any): AxiosPromise<void> {
            return BlockedServicesApiFp(configuration).blockedServicesSet(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockedServicesApi - object-oriented interface
 * @export
 * @class BlockedServicesApi
 * @extends {BaseAPI}
 */
export class BlockedServicesApi extends BaseAPI {
    /**
     * 
     * @summary Get blocked services list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedServicesApi
     */
    public blockedServicesList(options?: any) {
        return BlockedServicesApiFp(this.configuration).blockedServicesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set blocked services list
     * @param {Array<string>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockedServicesApi
     */
    public blockedServicesSet(body?: Array<string>, options?: any) {
        return BlockedServicesApiFp(this.configuration).blockedServicesSet(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new client
         * @param {Client} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsAdd: async (body: Client, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clientsAdd.');
            }
            const localVarPath = `/clients/add`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a client
         * @param {ClientDelete} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsDelete: async (body: ClientDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clientsDelete.');
            }
            const localVarPath = `/clients/delete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about selected clients by their IP address
         * @param {string} [ip0] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsFind: async (ip0?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients/find`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ip0 !== undefined) {
                localVarQueryParameter['ip0'] = ip0;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about configured clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update client information
         * @param {ClientUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsUpdate: async (body: ClientUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clientsUpdate.');
            }
            const localVarPath = `/clients/update`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new client
         * @param {Client} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsAdd(body: Client, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsAdd(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove a client
         * @param {ClientDelete} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsDelete(body: ClientDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsDelete(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get information about selected clients by their IP address
         * @param {string} [ip0] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsFind(ip0?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientsFindEntry>>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsFind(ip0, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get information about configured clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Clients>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update client information
         * @param {ClientUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsUpdate(body: ClientUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientsApiAxiosParamCreator(configuration).clientsUpdate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a new client
         * @param {Client} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsAdd(body: Client, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).clientsAdd(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a client
         * @param {ClientDelete} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsDelete(body: ClientDelete, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).clientsDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about selected clients by their IP address
         * @param {string} [ip0] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsFind(ip0?: string, options?: any): AxiosPromise<Array<ClientsFindEntry>> {
            return ClientsApiFp(configuration).clientsFind(ip0, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about configured clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsStatus(options?: any): AxiosPromise<Clients> {
            return ClientsApiFp(configuration).clientsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update client information
         * @param {ClientUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsUpdate(body: ClientUpdate, options?: any): AxiosPromise<void> {
            return ClientsApiFp(configuration).clientsUpdate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new client
     * @param {Client} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsAdd(body: Client, options?: any) {
        return ClientsApiFp(this.configuration).clientsAdd(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a client
     * @param {ClientDelete} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsDelete(body: ClientDelete, options?: any) {
        return ClientsApiFp(this.configuration).clientsDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about selected clients by their IP address
     * @param {string} [ip0] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsFind(ip0?: string, options?: any) {
        return ClientsApiFp(this.configuration).clientsFind(ip0, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about configured clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsStatus(options?: any) {
        return ClientsApiFp(this.configuration).clientsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update client information
     * @param {ClientUpdate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsUpdate(body: ClientUpdate, options?: any) {
        return ClientsApiFp(this.configuration).clientsUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DhcpApi - axios parameter creator
 * @export
 */
export const DhcpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Searches for an active DHCP server on the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActiveDhcp: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dhcp/find_active_dhcp`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a static lease
         * @param {DhcpStaticLease} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpAddStaticLease: async (body: DhcpStaticLease, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dhcpAddStaticLease.');
            }
            const localVarPath = `/dhcp/add_static_lease`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a static lease
         * @param {DhcpStaticLease} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpRemoveStaticLease: async (body: DhcpStaticLease, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dhcpRemoveStaticLease.');
            }
            const localVarPath = `/dhcp/remove_static_lease`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset DHCP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpReset: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dhcp/reset`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the current DHCP server configuration
         * @param {DhcpConfig} body DHCP configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpSetConfig: async (body: DhcpConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dhcpSetConfig.');
            }
            const localVarPath = `/dhcp/set_config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the current DHCP settings and status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dhcp/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DhcpApi - functional programming interface
 * @export
 */
export const DhcpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Searches for an active DHCP server on the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkActiveDhcp(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DhcpSearchResult>> {
            const localVarAxiosArgs = await DhcpApiAxiosParamCreator(configuration).checkActiveDhcp(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a static lease
         * @param {DhcpStaticLease} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dhcpAddStaticLease(body: DhcpStaticLease, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DhcpApiAxiosParamCreator(configuration).dhcpAddStaticLease(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes a static lease
         * @param {DhcpStaticLease} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dhcpRemoveStaticLease(body: DhcpStaticLease, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DhcpApiAxiosParamCreator(configuration).dhcpRemoveStaticLease(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reset DHCP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dhcpReset(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DhcpApiAxiosParamCreator(configuration).dhcpReset(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the current DHCP server configuration
         * @param {DhcpConfig} body DHCP configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dhcpSetConfig(body: DhcpConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DhcpApiAxiosParamCreator(configuration).dhcpSetConfig(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the current DHCP settings and status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dhcpStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DhcpStatus>> {
            const localVarAxiosArgs = await DhcpApiAxiosParamCreator(configuration).dhcpStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DhcpApi - factory interface
 * @export
 */
export const DhcpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Searches for an active DHCP server on the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActiveDhcp(options?: any): AxiosPromise<DhcpSearchResult> {
            return DhcpApiFp(configuration).checkActiveDhcp(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a static lease
         * @param {DhcpStaticLease} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpAddStaticLease(body: DhcpStaticLease, options?: any): AxiosPromise<void> {
            return DhcpApiFp(configuration).dhcpAddStaticLease(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a static lease
         * @param {DhcpStaticLease} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpRemoveStaticLease(body: DhcpStaticLease, options?: any): AxiosPromise<void> {
            return DhcpApiFp(configuration).dhcpRemoveStaticLease(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset DHCP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpReset(options?: any): AxiosPromise<void> {
            return DhcpApiFp(configuration).dhcpReset(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the current DHCP server configuration
         * @param {DhcpConfig} body DHCP configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpSetConfig(body: DhcpConfig, options?: any): AxiosPromise<void> {
            return DhcpApiFp(configuration).dhcpSetConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the current DHCP settings and status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dhcpStatus(options?: any): AxiosPromise<DhcpStatus> {
            return DhcpApiFp(configuration).dhcpStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DhcpApi - object-oriented interface
 * @export
 * @class DhcpApi
 * @extends {BaseAPI}
 */
export class DhcpApi extends BaseAPI {
    /**
     * 
     * @summary Searches for an active DHCP server on the network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpApi
     */
    public checkActiveDhcp(options?: any) {
        return DhcpApiFp(this.configuration).checkActiveDhcp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a static lease
     * @param {DhcpStaticLease} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpApi
     */
    public dhcpAddStaticLease(body: DhcpStaticLease, options?: any) {
        return DhcpApiFp(this.configuration).dhcpAddStaticLease(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a static lease
     * @param {DhcpStaticLease} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpApi
     */
    public dhcpRemoveStaticLease(body: DhcpStaticLease, options?: any) {
        return DhcpApiFp(this.configuration).dhcpRemoveStaticLease(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset DHCP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpApi
     */
    public dhcpReset(options?: any) {
        return DhcpApiFp(this.configuration).dhcpReset(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the current DHCP server configuration
     * @param {DhcpConfig} body DHCP configuration JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpApi
     */
    public dhcpSetConfig(body: DhcpConfig, options?: any) {
        return DhcpApiFp(this.configuration).dhcpSetConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the current DHCP settings and status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpApi
     */
    public dhcpStatus(options?: any) {
        return DhcpApiFp(this.configuration).dhcpStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FilteringApi - axios parameter creator
 * @export
 */
export const FilteringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add filter URL or an absolute file path
         * @param {AddUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringAddURL: async (body: AddUrlRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling filteringAddURL.');
            }
            const localVarPath = `/filtering/add_url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if host name is filtered
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringCheckHost: async (name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/filtering/check_host`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set filtering parameters
         * @param {FilterConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringConfig: async (body: FilterConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling filteringConfig.');
            }
            const localVarPath = `/filtering/config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reload filtering rules from URLs  This might be needed if new URL was just added and you dont want to wait for automatic refresh to kick in.  This API request is ratelimited, so you can call it freely as often as you like, it wont create unneccessary burden on servers that host the URL.  This should work as intended, a `force` parameter is offered as last-resort attempt to make filter lists fresh.  If you ever find yourself using `force` to make something work that otherwise wont, this is a bug and report it accordingly. 
         * @param {FilterRefreshRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringRefresh: async (body?: FilterRefreshRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/filtering/refresh`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove filter URL
         * @param {RemoveUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringRemoveURL: async (body: RemoveUrlRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling filteringRemoveURL.');
            }
            const localVarPath = `/filtering/remove_url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set user-defined filter rules
         * @param {string} [rules] All filtering rules, one line per rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringSetRules: async (rules?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/filtering/set_rules`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rules !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rules !== undefined ? rules : {}) : (rules || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set URL parameters
         * @param {FilterSetUrl} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringSetURL: async (body?: FilterSetUrl, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/filtering/set_url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get filtering parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/filtering/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilteringApi - functional programming interface
 * @export
 */
export const FilteringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add filter URL or an absolute file path
         * @param {AddUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringAddURL(body: AddUrlRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringAddURL(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check if host name is filtered
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringCheckHost(name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterCheckHostResponse>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringCheckHost(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set filtering parameters
         * @param {FilterConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringConfig(body: FilterConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringConfig(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reload filtering rules from URLs  This might be needed if new URL was just added and you dont want to wait for automatic refresh to kick in.  This API request is ratelimited, so you can call it freely as often as you like, it wont create unneccessary burden on servers that host the URL.  This should work as intended, a `force` parameter is offered as last-resort attempt to make filter lists fresh.  If you ever find yourself using `force` to make something work that otherwise wont, this is a bug and report it accordingly. 
         * @param {FilterRefreshRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringRefresh(body?: FilterRefreshRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterRefreshResponse>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringRefresh(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove filter URL
         * @param {RemoveUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringRemoveURL(body: RemoveUrlRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringRemoveURL(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set user-defined filter rules
         * @param {string} [rules] All filtering rules, one line per rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringSetRules(rules?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringSetRules(rules, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set URL parameters
         * @param {FilterSetUrl} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringSetURL(body?: FilterSetUrl, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringSetURL(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get filtering parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filteringStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterStatus>> {
            const localVarAxiosArgs = await FilteringApiAxiosParamCreator(configuration).filteringStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilteringApi - factory interface
 * @export
 */
export const FilteringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add filter URL or an absolute file path
         * @param {AddUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringAddURL(body: AddUrlRequest, options?: any): AxiosPromise<void> {
            return FilteringApiFp(configuration).filteringAddURL(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if host name is filtered
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringCheckHost(name?: string, options?: any): AxiosPromise<FilterCheckHostResponse> {
            return FilteringApiFp(configuration).filteringCheckHost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set filtering parameters
         * @param {FilterConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringConfig(body: FilterConfig, options?: any): AxiosPromise<void> {
            return FilteringApiFp(configuration).filteringConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reload filtering rules from URLs  This might be needed if new URL was just added and you dont want to wait for automatic refresh to kick in.  This API request is ratelimited, so you can call it freely as often as you like, it wont create unneccessary burden on servers that host the URL.  This should work as intended, a `force` parameter is offered as last-resort attempt to make filter lists fresh.  If you ever find yourself using `force` to make something work that otherwise wont, this is a bug and report it accordingly. 
         * @param {FilterRefreshRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringRefresh(body?: FilterRefreshRequest, options?: any): AxiosPromise<FilterRefreshResponse> {
            return FilteringApiFp(configuration).filteringRefresh(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove filter URL
         * @param {RemoveUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringRemoveURL(body: RemoveUrlRequest, options?: any): AxiosPromise<void> {
            return FilteringApiFp(configuration).filteringRemoveURL(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set user-defined filter rules
         * @param {string} [rules] All filtering rules, one line per rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringSetRules(rules?: string, options?: any): AxiosPromise<void> {
            return FilteringApiFp(configuration).filteringSetRules(rules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set URL parameters
         * @param {FilterSetUrl} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringSetURL(body?: FilterSetUrl, options?: any): AxiosPromise<void> {
            return FilteringApiFp(configuration).filteringSetURL(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get filtering parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filteringStatus(options?: any): AxiosPromise<FilterStatus> {
            return FilteringApiFp(configuration).filteringStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilteringApi - object-oriented interface
 * @export
 * @class FilteringApi
 * @extends {BaseAPI}
 */
export class FilteringApi extends BaseAPI {
    /**
     * 
     * @summary Add filter URL or an absolute file path
     * @param {AddUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringAddURL(body: AddUrlRequest, options?: any) {
        return FilteringApiFp(this.configuration).filteringAddURL(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if host name is filtered
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringCheckHost(name?: string, options?: any) {
        return FilteringApiFp(this.configuration).filteringCheckHost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set filtering parameters
     * @param {FilterConfig} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringConfig(body: FilterConfig, options?: any) {
        return FilteringApiFp(this.configuration).filteringConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reload filtering rules from URLs  This might be needed if new URL was just added and you dont want to wait for automatic refresh to kick in.  This API request is ratelimited, so you can call it freely as often as you like, it wont create unneccessary burden on servers that host the URL.  This should work as intended, a `force` parameter is offered as last-resort attempt to make filter lists fresh.  If you ever find yourself using `force` to make something work that otherwise wont, this is a bug and report it accordingly. 
     * @param {FilterRefreshRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringRefresh(body?: FilterRefreshRequest, options?: any) {
        return FilteringApiFp(this.configuration).filteringRefresh(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove filter URL
     * @param {RemoveUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringRemoveURL(body: RemoveUrlRequest, options?: any) {
        return FilteringApiFp(this.configuration).filteringRemoveURL(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set user-defined filter rules
     * @param {string} [rules] All filtering rules, one line per rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringSetRules(rules?: string, options?: any) {
        return FilteringApiFp(this.configuration).filteringSetRules(rules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set URL parameters
     * @param {FilterSetUrl} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringSetURL(body?: FilterSetUrl, options?: any) {
        return FilteringApiFp(this.configuration).filteringSetURL(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get filtering parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilteringApi
     */
    public filteringStatus(options?: any) {
        return FilteringApiFp(this.configuration).filteringStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GlobalApi - axios parameter creator
 * @export
 */
export const GlobalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Begin auto-upgrade procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beginUpdate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/update`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set general DNS parameters
         * @param {DNSConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsConfig: async (body?: DNSConfig, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dns_config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get general DNS parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dns_info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets information about the latest available version of AdGuard
         * @param {GetVersionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionJson: async (body: GetVersionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getVersionJson.');
            }
            const localVarPath = `/version.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform administrator log-in
         * @param {Login} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (body: Login, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform administrator log-out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get DNS server current status and general settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test upstream configuration
         * @param {UpstreamsConfig} [body] Upstream configuration to be tested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpstreamDNS: async (body?: UpstreamsConfig, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/test_upstream_dns`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalApi - functional programming interface
 * @export
 */
export const GlobalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Begin auto-upgrade procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async beginUpdate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).beginUpdate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set general DNS parameters
         * @param {DNSConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsConfig(body?: DNSConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).dnsConfig(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get general DNS parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSConfig>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).dnsInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileInfo>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).getProfile(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets information about the latest available version of AdGuard
         * @param {GetVersionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionJson(body: GetVersionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionInfo>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).getVersionJson(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform administrator log-in
         * @param {Login} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(body: Login, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).login(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform administrator log-out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).logout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get DNS server current status and general settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatus>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).status(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Test upstream configuration
         * @param {UpstreamsConfig} [body] Upstream configuration to be tested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testUpstreamDNS(body?: UpstreamsConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GlobalApiAxiosParamCreator(configuration).testUpstreamDNS(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GlobalApi - factory interface
 * @export
 */
export const GlobalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Begin auto-upgrade procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        beginUpdate(options?: any): AxiosPromise<void> {
            return GlobalApiFp(configuration).beginUpdate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set general DNS parameters
         * @param {DNSConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsConfig(body?: DNSConfig, options?: any): AxiosPromise<void> {
            return GlobalApiFp(configuration).dnsConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get general DNS parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsInfo(options?: any): AxiosPromise<DNSConfig> {
            return GlobalApiFp(configuration).dnsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any): AxiosPromise<ProfileInfo> {
            return GlobalApiFp(configuration).getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets information about the latest available version of AdGuard
         * @param {GetVersionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionJson(body: GetVersionRequest, options?: any): AxiosPromise<VersionInfo> {
            return GlobalApiFp(configuration).getVersionJson(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform administrator log-in
         * @param {Login} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: Login, options?: any): AxiosPromise<void> {
            return GlobalApiFp(configuration).login(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform administrator log-out
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return GlobalApiFp(configuration).logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get DNS server current status and general settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(options?: any): AxiosPromise<ServerStatus> {
            return GlobalApiFp(configuration).status(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test upstream configuration
         * @param {UpstreamsConfig} [body] Upstream configuration to be tested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUpstreamDNS(body?: UpstreamsConfig, options?: any): AxiosPromise<void> {
            return GlobalApiFp(configuration).testUpstreamDNS(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlobalApi - object-oriented interface
 * @export
 * @class GlobalApi
 * @extends {BaseAPI}
 */
export class GlobalApi extends BaseAPI {
    /**
     * 
     * @summary Begin auto-upgrade procedure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public beginUpdate(options?: any) {
        return GlobalApiFp(this.configuration).beginUpdate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set general DNS parameters
     * @param {DNSConfig} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public dnsConfig(body?: DNSConfig, options?: any) {
        return GlobalApiFp(this.configuration).dnsConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get general DNS parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public dnsInfo(options?: any) {
        return GlobalApiFp(this.configuration).dnsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public getProfile(options?: any) {
        return GlobalApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets information about the latest available version of AdGuard
     * @param {GetVersionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public getVersionJson(body: GetVersionRequest, options?: any) {
        return GlobalApiFp(this.configuration).getVersionJson(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform administrator log-in
     * @param {Login} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public login(body: Login, options?: any) {
        return GlobalApiFp(this.configuration).login(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform administrator log-out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public logout(options?: any) {
        return GlobalApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get DNS server current status and general settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public status(options?: any) {
        return GlobalApiFp(this.configuration).status(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test upstream configuration
     * @param {UpstreamsConfig} [body] Upstream configuration to be tested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalApi
     */
    public testUpstreamDNS(body?: UpstreamsConfig, options?: any) {
        return GlobalApiFp(this.configuration).testUpstreamDNS(body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * I18nApi - axios parameter creator
 * @export
 */
export const I18nApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change current language. Argument must be an ISO 639-1 two-letter code
         * @param {string} [language] New language. It must be known to the server and must be an ISO 639-1 two-letter code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLanguage: async (language?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/i18n/change_language`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof language !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(language !== undefined ? language : {}) : (language || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get currently set language. Result is ISO 639-1 two-letter code. Empty result means default language.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentLanguage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/i18n/current_language`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * I18nApi - functional programming interface
 * @export
 */
export const I18nApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change current language. Argument must be an ISO 639-1 two-letter code
         * @param {string} [language] New language. It must be known to the server and must be an ISO 639-1 two-letter code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeLanguage(language?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await I18nApiAxiosParamCreator(configuration).changeLanguage(language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get currently set language. Result is ISO 639-1 two-letter code. Empty result means default language.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentLanguage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await I18nApiAxiosParamCreator(configuration).currentLanguage(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * I18nApi - factory interface
 * @export
 */
export const I18nApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Change current language. Argument must be an ISO 639-1 two-letter code
         * @param {string} [language] New language. It must be known to the server and must be an ISO 639-1 two-letter code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLanguage(language?: string, options?: any): AxiosPromise<void> {
            return I18nApiFp(configuration).changeLanguage(language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get currently set language. Result is ISO 639-1 two-letter code. Empty result means default language.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentLanguage(options?: any): AxiosPromise<void> {
            return I18nApiFp(configuration).currentLanguage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * I18nApi - object-oriented interface
 * @export
 * @class I18nApi
 * @extends {BaseAPI}
 */
export class I18nApi extends BaseAPI {
    /**
     * 
     * @summary Change current language. Argument must be an ISO 639-1 two-letter code
     * @param {string} [language] New language. It must be known to the server and must be an ISO 639-1 two-letter code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof I18nApi
     */
    public changeLanguage(language?: string, options?: any) {
        return I18nApiFp(this.configuration).changeLanguage(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get currently set language. Result is ISO 639-1 two-letter code. Empty result means default language.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof I18nApi
     */
    public currentLanguage(options?: any) {
        return I18nApiFp(this.configuration).currentLanguage(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InstallApi - axios parameter creator
 * @export
 */
export const InstallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks configuration
         * @param {CheckConfigRequest} body Configuration to be checked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installCheckConfig: async (body: CheckConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling installCheckConfig.');
            }
            const localVarPath = `/install/check_config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Applies the initial configuration.
         * @param {InitialConfiguration} body Initial configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installConfigure: async (body: InitialConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling installConfigure.');
            }
            const localVarPath = `/install/configure`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the network interfaces information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installGetAddresses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/install/get_addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstallApi - functional programming interface
 * @export
 */
export const InstallApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks configuration
         * @param {CheckConfigRequest} body Configuration to be checked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installCheckConfig(body: CheckConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckConfigResponse>> {
            const localVarAxiosArgs = await InstallApiAxiosParamCreator(configuration).installCheckConfig(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Applies the initial configuration.
         * @param {InitialConfiguration} body Initial configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installConfigure(body: InitialConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InstallApiAxiosParamCreator(configuration).installConfigure(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the network interfaces information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installGetAddresses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesInfo>> {
            const localVarAxiosArgs = await InstallApiAxiosParamCreator(configuration).installGetAddresses(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstallApi - factory interface
 * @export
 */
export const InstallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Checks configuration
         * @param {CheckConfigRequest} body Configuration to be checked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installCheckConfig(body: CheckConfigRequest, options?: any): AxiosPromise<CheckConfigResponse> {
            return InstallApiFp(configuration).installCheckConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Applies the initial configuration.
         * @param {InitialConfiguration} body Initial configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installConfigure(body: InitialConfiguration, options?: any): AxiosPromise<void> {
            return InstallApiFp(configuration).installConfigure(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the network interfaces information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installGetAddresses(options?: any): AxiosPromise<AddressesInfo> {
            return InstallApiFp(configuration).installGetAddresses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstallApi - object-oriented interface
 * @export
 * @class InstallApi
 * @extends {BaseAPI}
 */
export class InstallApi extends BaseAPI {
    /**
     * 
     * @summary Checks configuration
     * @param {CheckConfigRequest} body Configuration to be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstallApi
     */
    public installCheckConfig(body: CheckConfigRequest, options?: any) {
        return InstallApiFp(this.configuration).installCheckConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Applies the initial configuration.
     * @param {InitialConfiguration} body Initial configuration JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstallApi
     */
    public installConfigure(body: InitialConfiguration, options?: any) {
        return InstallApiFp(this.configuration).installConfigure(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the network interfaces information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstallApi
     */
    public installGetAddresses(options?: any) {
        return InstallApiFp(this.configuration).installGetAddresses(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get DNS server query log
         * @param {string} [olderThan] 
         * @param {string} [filterDomain] Filter by domain name
         * @param {string} [filterClient] Filter by client
         * @param {string} [filterQuestionType] Filter by question type
         * @param {'null' | 'filtered'} [filterResponseStatus] Filter by response status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLog: async (olderThan?: string, filterDomain?: string, filterClient?: string, filterQuestionType?: string, filterResponseStatus?: 'null' | 'filtered', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/querylog`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (olderThan !== undefined) {
                localVarQueryParameter['older_than'] = olderThan;
            }

            if (filterDomain !== undefined) {
                localVarQueryParameter['filter_domain'] = filterDomain;
            }

            if (filterClient !== undefined) {
                localVarQueryParameter['filter_client'] = filterClient;
            }

            if (filterQuestionType !== undefined) {
                localVarQueryParameter['filter_question_type'] = filterQuestionType;
            }

            if (filterResponseStatus !== undefined) {
                localVarQueryParameter['filter_response_status'] = filterResponseStatus;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set query log parameters
         * @param {QueryLogConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLogConfig: async (body?: QueryLogConfig, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/querylog_config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get query log parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLogInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/querylog_info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear query log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querylogClear: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/querylog_clear`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get DNS server query log
         * @param {string} [olderThan] 
         * @param {string} [filterDomain] Filter by domain name
         * @param {string} [filterClient] Filter by client
         * @param {string} [filterQuestionType] Filter by question type
         * @param {'null' | 'filtered'} [filterResponseStatus] Filter by response status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryLog(olderThan?: string, filterDomain?: string, filterClient?: string, filterQuestionType?: string, filterResponseStatus?: 'null' | 'filtered', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryLog>> {
            const localVarAxiosArgs = await LogApiAxiosParamCreator(configuration).queryLog(olderThan, filterDomain, filterClient, filterQuestionType, filterResponseStatus, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set query log parameters
         * @param {QueryLogConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryLogConfig(body?: QueryLogConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LogApiAxiosParamCreator(configuration).queryLogConfig(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get query log parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryLogInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryLogConfig>> {
            const localVarAxiosArgs = await LogApiAxiosParamCreator(configuration).queryLogInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Clear query log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querylogClear(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LogApiAxiosParamCreator(configuration).querylogClear(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get DNS server query log
         * @param {string} [olderThan] 
         * @param {string} [filterDomain] Filter by domain name
         * @param {string} [filterClient] Filter by client
         * @param {string} [filterQuestionType] Filter by question type
         * @param {'null' | 'filtered'} [filterResponseStatus] Filter by response status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLog(olderThan?: string, filterDomain?: string, filterClient?: string, filterQuestionType?: string, filterResponseStatus?: 'null' | 'filtered', options?: any): AxiosPromise<QueryLog> {
            return LogApiFp(configuration).queryLog(olderThan, filterDomain, filterClient, filterQuestionType, filterResponseStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set query log parameters
         * @param {QueryLogConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLogConfig(body?: QueryLogConfig, options?: any): AxiosPromise<void> {
            return LogApiFp(configuration).queryLogConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get query log parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLogInfo(options?: any): AxiosPromise<QueryLogConfig> {
            return LogApiFp(configuration).queryLogInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear query log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querylogClear(options?: any): AxiosPromise<void> {
            return LogApiFp(configuration).querylogClear(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI {
    /**
     * 
     * @summary Get DNS server query log
     * @param {string} [olderThan] 
     * @param {string} [filterDomain] Filter by domain name
     * @param {string} [filterClient] Filter by client
     * @param {string} [filterQuestionType] Filter by question type
     * @param {'null' | 'filtered'} [filterResponseStatus] Filter by response status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public queryLog(olderThan?: string, filterDomain?: string, filterClient?: string, filterQuestionType?: string, filterResponseStatus?: 'null' | 'filtered', options?: any) {
        return LogApiFp(this.configuration).queryLog(olderThan, filterDomain, filterClient, filterQuestionType, filterResponseStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set query log parameters
     * @param {QueryLogConfig} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public queryLogConfig(body?: QueryLogConfig, options?: any) {
        return LogApiFp(this.configuration).queryLogConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get query log parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public queryLogInfo(options?: any) {
        return LogApiFp(this.configuration).queryLogInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear query log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public querylogClear(options?: any) {
        return LogApiFp(this.configuration).querylogClear(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ParentalApi - axios parameter creator
 * @export
 */
export const ParentalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable parental filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parentalDisable: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/parental/disable`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable parental filtering
         * @param {string} sensitivity Age sensitivity for parental filtering, EARLY_CHILDHOOD is 3 YOUNG is 10 TEEN is 13 MATURE is 17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parentalEnable: async (sensitivity: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sensitivity' is not null or undefined
            if (sensitivity === null || sensitivity === undefined) {
                throw new RequiredError('sensitivity','Required parameter sensitivity was null or undefined when calling parentalEnable.');
            }
            const localVarPath = `/parental/enable`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof sensitivity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sensitivity !== undefined ? sensitivity : {}) : (sensitivity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get parental filtering status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parentalStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/parental/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParentalApi - functional programming interface
 * @export
 */
export const ParentalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable parental filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parentalDisable(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ParentalApiAxiosParamCreator(configuration).parentalDisable(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Enable parental filtering
         * @param {string} sensitivity Age sensitivity for parental filtering, EARLY_CHILDHOOD is 3 YOUNG is 10 TEEN is 13 MATURE is 17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parentalEnable(sensitivity: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ParentalApiAxiosParamCreator(configuration).parentalEnable(sensitivity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get parental filtering status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parentalStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ParentalApiAxiosParamCreator(configuration).parentalStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ParentalApi - factory interface
 * @export
 */
export const ParentalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Disable parental filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parentalDisable(options?: any): AxiosPromise<void> {
            return ParentalApiFp(configuration).parentalDisable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable parental filtering
         * @param {string} sensitivity Age sensitivity for parental filtering, EARLY_CHILDHOOD is 3 YOUNG is 10 TEEN is 13 MATURE is 17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parentalEnable(sensitivity: string, options?: any): AxiosPromise<void> {
            return ParentalApiFp(configuration).parentalEnable(sensitivity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get parental filtering status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parentalStatus(options?: any): AxiosPromise<void> {
            return ParentalApiFp(configuration).parentalStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParentalApi - object-oriented interface
 * @export
 * @class ParentalApi
 * @extends {BaseAPI}
 */
export class ParentalApi extends BaseAPI {
    /**
     * 
     * @summary Disable parental filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParentalApi
     */
    public parentalDisable(options?: any) {
        return ParentalApiFp(this.configuration).parentalDisable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable parental filtering
     * @param {string} sensitivity Age sensitivity for parental filtering, EARLY_CHILDHOOD is 3 YOUNG is 10 TEEN is 13 MATURE is 17 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParentalApi
     */
    public parentalEnable(sensitivity: string, options?: any) {
        return ParentalApiFp(this.configuration).parentalEnable(sensitivity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get parental filtering status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParentalApi
     */
    public parentalStatus(options?: any) {
        return ParentalApiFp(this.configuration).parentalStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RewriteApi - axios parameter creator
 * @export
 */
export const RewriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Rewrite rule
         * @param {RewriteEntry} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewriteAdd: async (body: RewriteEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rewriteAdd.');
            }
            const localVarPath = `/rewrite/add`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a Rewrite rule
         * @param {RewriteEntry} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewriteDelete: async (body: RewriteEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rewriteDelete.');
            }
            const localVarPath = `/rewrite/delete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of Rewrite rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewriteList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewrite/list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewriteApi - functional programming interface
 * @export
 */
export const RewriteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Rewrite rule
         * @param {RewriteEntry} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewriteAdd(body: RewriteEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RewriteApiAxiosParamCreator(configuration).rewriteAdd(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove a Rewrite rule
         * @param {RewriteEntry} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewriteDelete(body: RewriteEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RewriteApiAxiosParamCreator(configuration).rewriteDelete(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of Rewrite rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewriteList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewriteEntry>>> {
            const localVarAxiosArgs = await RewriteApiAxiosParamCreator(configuration).rewriteList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RewriteApi - factory interface
 * @export
 */
export const RewriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a new Rewrite rule
         * @param {RewriteEntry} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewriteAdd(body: RewriteEntry, options?: any): AxiosPromise<void> {
            return RewriteApiFp(configuration).rewriteAdd(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a Rewrite rule
         * @param {RewriteEntry} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewriteDelete(body: RewriteEntry, options?: any): AxiosPromise<void> {
            return RewriteApiFp(configuration).rewriteDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of Rewrite rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewriteList(options?: any): AxiosPromise<Array<RewriteEntry>> {
            return RewriteApiFp(configuration).rewriteList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewriteApi - object-oriented interface
 * @export
 * @class RewriteApi
 * @extends {BaseAPI}
 */
export class RewriteApi extends BaseAPI {
    /**
     * 
     * @summary Add a new Rewrite rule
     * @param {RewriteEntry} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewriteApi
     */
    public rewriteAdd(body: RewriteEntry, options?: any) {
        return RewriteApiFp(this.configuration).rewriteAdd(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a Rewrite rule
     * @param {RewriteEntry} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewriteApi
     */
    public rewriteDelete(body: RewriteEntry, options?: any) {
        return RewriteApiFp(this.configuration).rewriteDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of Rewrite rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewriteApi
     */
    public rewriteList(options?: any) {
        return RewriteApiFp(this.configuration).rewriteList(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SafebrowsingApi - axios parameter creator
 * @export
 */
export const SafebrowsingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable safebrowsing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safebrowsingDisable: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/safebrowsing/disable`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable safebrowsing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safebrowsingEnable: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/safebrowsing/enable`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get safebrowsing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safebrowsingStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/safebrowsing/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafebrowsingApi - functional programming interface
 * @export
 */
export const SafebrowsingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable safebrowsing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safebrowsingDisable(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafebrowsingApiAxiosParamCreator(configuration).safebrowsingDisable(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Enable safebrowsing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safebrowsingEnable(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafebrowsingApiAxiosParamCreator(configuration).safebrowsingEnable(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get safebrowsing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safebrowsingStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafebrowsingApiAxiosParamCreator(configuration).safebrowsingStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SafebrowsingApi - factory interface
 * @export
 */
export const SafebrowsingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Disable safebrowsing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safebrowsingDisable(options?: any): AxiosPromise<void> {
            return SafebrowsingApiFp(configuration).safebrowsingDisable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable safebrowsing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safebrowsingEnable(options?: any): AxiosPromise<void> {
            return SafebrowsingApiFp(configuration).safebrowsingEnable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get safebrowsing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safebrowsingStatus(options?: any): AxiosPromise<void> {
            return SafebrowsingApiFp(configuration).safebrowsingStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafebrowsingApi - object-oriented interface
 * @export
 * @class SafebrowsingApi
 * @extends {BaseAPI}
 */
export class SafebrowsingApi extends BaseAPI {
    /**
     * 
     * @summary Disable safebrowsing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafebrowsingApi
     */
    public safebrowsingDisable(options?: any) {
        return SafebrowsingApiFp(this.configuration).safebrowsingDisable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable safebrowsing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafebrowsingApi
     */
    public safebrowsingEnable(options?: any) {
        return SafebrowsingApiFp(this.configuration).safebrowsingEnable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get safebrowsing status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafebrowsingApi
     */
    public safebrowsingStatus(options?: any) {
        return SafebrowsingApiFp(this.configuration).safebrowsingStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SafesearchApi - axios parameter creator
 * @export
 */
export const SafesearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable safesearch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesearchDisable: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/safesearch/disable`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable safesearch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesearchEnable: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/safesearch/enable`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get safesearch status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesearchStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/safesearch/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafesearchApi - functional programming interface
 * @export
 */
export const SafesearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable safesearch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesearchDisable(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesearchApiAxiosParamCreator(configuration).safesearchDisable(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Enable safesearch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesearchEnable(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesearchApiAxiosParamCreator(configuration).safesearchEnable(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get safesearch status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesearchStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesearchApiAxiosParamCreator(configuration).safesearchStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SafesearchApi - factory interface
 * @export
 */
export const SafesearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Disable safesearch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesearchDisable(options?: any): AxiosPromise<void> {
            return SafesearchApiFp(configuration).safesearchDisable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable safesearch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesearchEnable(options?: any): AxiosPromise<void> {
            return SafesearchApiFp(configuration).safesearchEnable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get safesearch status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesearchStatus(options?: any): AxiosPromise<void> {
            return SafesearchApiFp(configuration).safesearchStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafesearchApi - object-oriented interface
 * @export
 * @class SafesearchApi
 * @extends {BaseAPI}
 */
export class SafesearchApi extends BaseAPI {
    /**
     * 
     * @summary Disable safesearch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesearchApi
     */
    public safesearchDisable(options?: any) {
        return SafesearchApiFp(this.configuration).safesearchDisable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable safesearch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesearchApi
     */
    public safesearchEnable(options?: any) {
        return SafesearchApiFp(this.configuration).safesearchEnable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get safesearch status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesearchApi
     */
    public safesearchStatus(options?: any) {
        return SafesearchApiFp(this.configuration).safesearchStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get DNS server statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set statistics parameters
         * @param {StatsConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsConfig: async (body?: StatsConfig, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats_config`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get statistics parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats_info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset all statistics to zeroes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReset: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats_reset`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get DNS server statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await StatsApiAxiosParamCreator(configuration).stats(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set statistics parameters
         * @param {StatsConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsConfig(body?: StatsConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StatsApiAxiosParamCreator(configuration).statsConfig(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get statistics parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsConfig>> {
            const localVarAxiosArgs = await StatsApiAxiosParamCreator(configuration).statsInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reset all statistics to zeroes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsReset(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StatsApiAxiosParamCreator(configuration).statsReset(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get DNS server statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stats(options?: any): AxiosPromise<Stats> {
            return StatsApiFp(configuration).stats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set statistics parameters
         * @param {StatsConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsConfig(body?: StatsConfig, options?: any): AxiosPromise<void> {
            return StatsApiFp(configuration).statsConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get statistics parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsInfo(options?: any): AxiosPromise<StatsConfig> {
            return StatsApiFp(configuration).statsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset all statistics to zeroes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReset(options?: any): AxiosPromise<void> {
            return StatsApiFp(configuration).statsReset(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * 
     * @summary Get DNS server statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public stats(options?: any) {
        return StatsApiFp(this.configuration).stats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set statistics parameters
     * @param {StatsConfig} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsConfig(body?: StatsConfig, options?: any) {
        return StatsApiFp(this.configuration).statsConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get statistics parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsInfo(options?: any) {
        return StatsApiFp(this.configuration).statsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset all statistics to zeroes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsReset(options?: any) {
        return StatsApiFp(this.configuration).statsReset(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TlsApi - axios parameter creator
 * @export
 */
export const TlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates current TLS configuration
         * @param {TlsConfig} body TLS configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tlsConfigure: async (body: TlsConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tlsConfigure.');
            }
            const localVarPath = `/tls/configure`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns TLS configuration and its status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tlsStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tls/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the current TLS configuration is valid
         * @param {TlsConfig} body TLS configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tlsValidate: async (body: TlsConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tlsValidate.');
            }
            const localVarPath = `/tls/validate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TlsApi - functional programming interface
 * @export
 */
export const TlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates current TLS configuration
         * @param {TlsConfig} body TLS configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tlsConfigure(body: TlsConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TlsConfig>> {
            const localVarAxiosArgs = await TlsApiAxiosParamCreator(configuration).tlsConfigure(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns TLS configuration and its status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tlsStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TlsConfig>> {
            const localVarAxiosArgs = await TlsApiAxiosParamCreator(configuration).tlsStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Checks if the current TLS configuration is valid
         * @param {TlsConfig} body TLS configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tlsValidate(body: TlsConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TlsConfig>> {
            const localVarAxiosArgs = await TlsApiAxiosParamCreator(configuration).tlsValidate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TlsApi - factory interface
 * @export
 */
export const TlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Updates current TLS configuration
         * @param {TlsConfig} body TLS configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tlsConfigure(body: TlsConfig, options?: any): AxiosPromise<TlsConfig> {
            return TlsApiFp(configuration).tlsConfigure(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns TLS configuration and its status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tlsStatus(options?: any): AxiosPromise<TlsConfig> {
            return TlsApiFp(configuration).tlsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the current TLS configuration is valid
         * @param {TlsConfig} body TLS configuration JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tlsValidate(body: TlsConfig, options?: any): AxiosPromise<TlsConfig> {
            return TlsApiFp(configuration).tlsValidate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TlsApi - object-oriented interface
 * @export
 * @class TlsApi
 * @extends {BaseAPI}
 */
export class TlsApi extends BaseAPI {
    /**
     * 
     * @summary Updates current TLS configuration
     * @param {TlsConfig} body TLS configuration JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TlsApi
     */
    public tlsConfigure(body: TlsConfig, options?: any) {
        return TlsApiFp(this.configuration).tlsConfigure(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns TLS configuration and its status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TlsApi
     */
    public tlsStatus(options?: any) {
        return TlsApiFp(this.configuration).tlsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the current TLS configuration is valid
     * @param {TlsConfig} body TLS configuration JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TlsApi
     */
    public tlsValidate(body: TlsConfig, options?: any) {
        return TlsApiFp(this.configuration).tlsValidate(body, options).then((request) => request(this.axios, this.basePath));
    }

}


